package s32x.sh2.drc;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import s32x.Sh2MMREG;
import s32x.bus.Sh2Bus;
import s32x.sh2.Sh2Context;
import s32x.sh2.device.Sh2DeviceHelper;
import s32x.sh2.prefetch.Sh2Prefetch;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Set;
import java.util.stream.Collectors;

import static s32x.sh2.drc.Ow2Sh2Helper.*;

/**
 * Federico Berti
 * <p>
 * Copyright 2022
 * <p>
 * This tests the boundaries between ASM generated bytecode and regular source code.
 */
public class Ow2Sh2MappingTest {

    @Test
    public void testFieldMapping() {
        Set<String> declFields = getDeclFields(Sh2Context.class);
        for (SH2CTX_CLASS_FIELD f : SH2CTX_CLASS_FIELD.values()) {
            Assertions.assertTrue(declFields.contains(f.name()));
        }

        declFields = getDeclFields(Sh2Prefetch.Sh2DrcContext.class);
        for (SH2_DRC_CTX_CLASS_FIELD f : SH2_DRC_CTX_CLASS_FIELD.values()) {
            Assertions.assertTrue(declFields.contains(f.name()));
        }

        declFields = getDeclFields(Sh2DeviceHelper.Sh2DeviceContext.class);
        for (SH2_DEVICE_CTX_CLASS_FIELD f : SH2_DEVICE_CTX_CLASS_FIELD.values()) {
            Assertions.assertTrue(declFields.contains(f.name()));
        }
    }

    @Test
    public void testMethodMapping() {
        Set<String> declMethods = getDeclMethods(Sh2MMREG.class);
        declMethods = getDeclMethods(Sh2Bus.class);
        for (SH2MEMORY_METHOD m : SH2MEMORY_METHOD.values()) {
            Assertions.assertTrue(declMethods.contains(m.name()), m.name());
        }
    }

    private Set<String> getDeclFields(Class<?> clazz) {
        return Arrays.stream(clazz.getDeclaredFields()).map(Field::getName).collect(Collectors.toSet());
    }

    private Set<String> getDeclMethods(Class<?> clazz) {
        return Arrays.stream(clazz.getDeclaredMethods()).map(Method::getName).collect(Collectors.toSet());
    }
}